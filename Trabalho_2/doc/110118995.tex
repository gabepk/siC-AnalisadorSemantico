\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  
\usepackage{indentfirst}
\usepackage{caption3}
\usepackage{color}
\usepackage{alltt}
\usepackage{url}
\usepackage{listings}

\lstset{ %
language=C,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=7pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
extendedchars=true,
emph={%  
    set, pair, bool%
    },emphstyle={\bfseries},
morekeywords={set, pair}
literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1
}
     
\sloppy

\title{siC: Uma linguagem baseada em C incluindo fila como tipo primitivo}

\author{Gabriella de Oliveira Esteves, 110118995}

\address{Departamento de Ciência da Computação - Universidade de Brasília}

\begin{document} 

\maketitle

%------------------------------------------------
\section{Objetivo}

Este trabalho visa projetar e construir uma nova linguagem chamada de siC - Structure in C, baseada na linguagem C. O siC acrescenta a estrutura de dados fila como tipo de dado primitivo e, para manipulá-la, adiciona certas operações próprias para tal.

%------------------------------------------------
\section{Introdução}

\indent Um compilador é um programa que recebe como entrada um código fonte e o traduz para um programa equilavente em outra linguagem \cite{book}. Ele pode ser dividido em sete fases, ilustrado na Figura \ref{fig:compilador}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.5\textwidth]{compilador.png}
  \caption{Fases de um compilador} \label{fig:compilador}
\end{figure}

\begin{itemize}
	\item[1] \textbf{Analisador Léxico:} Lê o código fonte e atribui significado à cada sequência de caracteres, agora chamados lexemas. Cada lexema é mapeado para um token, que por sua vez é um par de nome (símbolo abstrato) e atributo (ponteiro para tabela de símbolos);
	\item[2] \textbf{Analisador Sintático:} Constrói uma representação gramátical dos tokens em forma de árvore;
	\item[3] \textbf{Analisador Semântico:} Utiliza a árvore sintática juntamente com a tabela de símbolos para verificar se a consistência semântica é mantida de acordo com a definição da linguagem.
	\item[4] \textbf{Gerador de Código Intermediário:} Converte árvore sintática anotada em código intermediário, com linguagem parecida com assembly e que possui apenas três operadores por linha de código. Nesse sentido, quebra-se estruturas complexas em estruturas mais simples, nesta fase.
	\item[5, 6] \textbf{Otimizador de Código Independente/Dependente de Máquina:} Procura aprimorar o código intermediário com o objetivo de melhorar o código-alvo de alguma forma: o deixando mais rápido, mais curto, consumindo menos energia, etc.
	\item[7] \textbf{Gerador de Código:} Converte o código intermediário no código-alvo, 	buscando atribuir os registradores às variáveis da maneira ótima.
\end{itemize}

\indent O foco do projeto será nas fase 1, 2, 3 e 4, porém a princípio serão apresentadas apenas a descrição da linguagem siC, uma breve descrição de sua semântica e o analisador léxico. Como a fila é uma das estruturas de dados mais básicas, é possível dizer que siC se destina a inúmeras áreas de Ciência da Computação, como, por exemplo, sistemas operacionais, onde ela é usada para organizar prioridades dos processos.

\indent Dois grandes motivos sustentam a escolha do tema deste projeto. Primeiro, uma vez que a fila faz parte dos tipos primitivos de uma linguagem, haverá menos manipulação de ponteiros na mesma, portanto erros envolvendo-os são menos prováveis de ocorrer. Segundo, a linguagem siC é mais alto-nível que C devido à abstração desta estrutura de dados básicas, e, de maneira geral, pode ser mais \textit{user-friendly}. Nesse sentido, o usuário (da linguagem) leigo deverá entender como a estrutura funciona, bem como suas vantagens/desvantagens e usabilidade; porém a implementação de cada uma estará a cargo da própria siC. 

\section{Gramática}

\indent A seguir será apresentada a gramática da linguagem siC, baseada em C \cite{yacc}. Alguns comentários são feitos ao longo da gramática para facilitar o entendimento das variáveis e nomenclatura utilizada. As palavras reservadas da linguagen são representadas aqui como \textit{tokens}. As variáveis e constantes são representadas como \textit{identifiers}, que por sua vez é uma expressão regular, e a única diferença entre este e \textit{identifier\_struct} é que o segundo tem acesso ao início da fila caso este seja o tipo do \textit{identifier}. 

\indent Algumas alterações e correções foram feitas na gramática:

\begin{itemize}
	\item Será implementado apenas a fila como tipo primitivo. Se fosse mantida a primeira proposta de incluir também o tipo pilha, talvez não seria possível terminar o projeto no prazo previsto;
	\item O tipo booleano deixará de existir em siC, porém o tipo float será incluído;
	\item Agora, além da variável \textit{argument}, também existe a \textit{arguments}, que permite a definição de zero ou mais argumentos em uma função;
	\item Na primeira versão da gramática o \textit{statement} estava envolvido entre chaves no IF e no WHILE, enquanto nesta versão as chaves não são mais obrigatórias, porém a regra \textit{statement $\rightarrow$ \{ statement \}} foi adicionada para criação de blocos;
	\item Expressões matemáticas são agora da forma \textit{identifier $\rightarrow$ assignment\_expression} ao invés de \textit{identifier $\rightarrow$ factor} para maior legibilidade;
	\item As aspas que delimitavam os símbolos como chaves e parênteses foram retiradas para aumentar também a legibilidade;
	\item Foram adicionados as operações de comparação \textit{<} e \textit{>};
	\item O símbolo \$ foi adicionado na variável \textit{letra}, pois em C ele pode compor um identificador;
	\item A variavel \textit{caractere} foi adicionada para representar o valor de um char, que só poderá ser ou uma letra ou um dígito.
\end{itemize}

Segue abaixo a gramática proposta cuja variável inicial é \textit{function}, com as alterações acima em vermelho e as características diferenciais da linguagem siC em negrito.
\begin{alltt}{\footnotesize

token: WHILE, IF, ELSE, RETURN 
token: QUEUE, FIRST, VOID, {\color{red}FLOAT}, INT, CHAR

function
   \(\to\) {\color{red}argument} ( arguments ) \{ statement RETURN identifier ; \}
    
identifier
   \(\to\) letra(letra | digito)*
   
{\color{red}caractere
   \(\to\) letra | digito}
    
letra
   \(\to\) a | b | \dots | z | A | B | \dots | Z | \$
   
digito
   \(\to\) 0 | 1 | \dots | 9
	
identifier\_struct
   \(\to\) identifier
    | \textbf{identifier . FIRST}	
	
type\_struct
   \(\to\) type\_simple
    | \textbf{type\_queue}
    
type\_simple
   \(\to\) VOID | {\color{red}FLOAT} | INT | CHAR
   
}\end{alltt}
\indent Existe um novo tipo de dado, \textit{QUEUE}, que será composto por tipos simples de dados apenas (ou seja, não será possível criar uma variável do tipo fila em que seus elementos também são filas). Caso a variável seja do tipo fila, ela poderá obter o primeiro elemento através do comando "identifier.FIRST".
\begin{alltt}{\footnotesize      

\textbf{type\_queue
   \(\to\) QUEUE < type\_simple >}

{\color{red}arguments
   \(\to\) arguments , argument
   | argument
   | \(\varepsilon\)}

argument
   \(\to\) type\_struct identifier
   
}\end{alltt}
\indent A seguir serão descritas quatro estruturas básicas da linguagem siC: comando com repetição, condicional, expressões matemáticas e expressões com pilhas e filas. A última contempla as operações de adicionar elemento no topo da pilha ou no fim da fila, "+", e remover do topo ou do início da fila, "-", onde o valor do elemento retirado é armazenado no último operando da expressão.
\begin{alltt}{\footnotesize

statements
   \(\to\) statements statement
   | \(\varepsilon\)

statement
   \(\to\) argument ';'
    | IF ( compare\_expression ) {\color{red}statement}
    | IF ( compare\_expression ) {\color{red}statement} ELSE {\color{red}statement}
    | WHILE ( compare\_expression ) {\color{red}statement}
    | identifier = {\color{red}assignment\_expression} ;
    | \textbf{identifier\_struct\_expression}
    | \{ statements \}
    
compare\_expression
   \(\to\) identifier\_struct compare\_assignment identifier\_struct
    
compare\_assignment
   \(\to\) == | != | <= | >= | {\color{red}<} | {\color{red}>}

assignment\_expressions
   \(\to\) assignment\_expression + term
    | assignment\_expression - term
    | term
    
term
   \(\to\) term * factor
    | term / factor
    | factor
    
factor
   \(\to\) identifier\_struct
    | {\color{red}' caractere '}
    | ( assignment\_expression )
    
\textbf{
identifier\_struct\_expression
   \(\to\) identifier = identifier + identifier ;
    | identifier = identifier - identifier ;
}		
}\end{alltt}

%\section{Analisador Léxico}

%\section{Analisador Sintático}

%\subsection{Árvore sintática}

%\subsection{Tabela de símbolos}

\section{Analisador Semântico}

\indent A análise semântica utiliza da árvore sintática para checar a consistência da linguagem. Uma de suas obrigações mais importantes é a checagem de tipo. No caso do siC, existem várias restrições a serem consideradas:
\begin{itemize}
    \item Para adicionar um elemento A em um identificador do tipo struct B, a atribuição deve ser do tipo B = B + A, onde A deverá ter tipo compatível com o de B;
    \item Para remover o topo/início de um identificador do tipo struct B, a atribuição deve ser do tipo B = B - A, onde A deverá ter tipo compatível com o de B;
    \item Nenhuma operação matemática (\textit{math\_expression}) pode conter um identificador do tipo pilha ou fila, apenas o topo ou início dos mesmos.
\end{itemize}


\indent Um exemplo de código em siC é aprensentado a seguir. O programa adiciona três elementos numa fila de inteiros e depois eles são somados um a um e armazenados na variável \textit{sum}. Ao final, a variável \textit{lixo}, recém retirada da fila, é adicionada à \textit{sum}. Nesse sentido, o resultado final de sum deve ser 7. \\

\begin{lstlisting}[language=C]
VOID main () {
    QUEUE<INT> q;
    INT sum, INT lixo;

    q = q + 0;
    q = q + 1;
    q = q + 2;
    q = q + 3;    
    sum = 0;
    
    WHILE (q.FIRST != 0) {    
        sum = (sum + q.FIRST);
        q = q - lixo;
    }
    sum = sum + lixo;

    RETURN 0;
}

\end{lstlisting}

%\section{Geração de código intermediário}

% \section{Considerações finais}

\begin{thebibliography}{1}
\bibitem{book}
A.~V.~Abo, M.~S.~Lam, R.~Sethi, J.~D.~Ullman, \emph{Compilers - Principles, Techniques and Tools}
\hskip 1em plus
	0.5em minus 0.4em\relax 2nd ed. 1986
	
\bibitem{yacc}
ANSI C Yacc grammar, \url{http://www.quut.com/c/ANSI-C-grammar-y.html}, 18 12 2012.
\end{thebibliography}
%------------------------------------------------
\end{document}